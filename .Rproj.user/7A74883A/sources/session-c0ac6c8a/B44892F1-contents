#' Automated Cell Type Annotation with GPT Models
#'
#' This function leverages OpenAI GPT models to annotate cell clusters based on marker genes.
#'
#' @param input A differential expression matrix (data.frame) with columns 'cluster', 'gene' and 'avg_log2FC',
#' or a predefined list of gene vectors.
#' @param tissuename Character string specifying tissue type (e.g. "human pancreas") to improve accuracy.
#' @param annotation_level Level of annotation, either "major" (broad cell types) or "subtype" (detailed cell types).
#' Default is "major".
#' @param model OpenAI model name, default "gpt-4o". Fallback options include "gpt-4-turbo".
#' @param topgenenumber Number of top marker genes to use per cluster (default: 10).
#' @param base_url API endpoint (for advanced users).
#' @param api_key OpenAI API key. If `NULL`, uses the `OPENAI_API_KEY` environment variable.
#' @param timeout Network timeout in seconds (default: 30).
#' @param retries Maximum retry attempts on API failure (default: 3).
#'
#' @return A data.frame with 4 columns:
#' \itemize{
#'   \item \code{Cluster}: Cluster identifier.
#'   \item \code{Prediction}: Annotated cell type (`NA` if failed).
#'   \item \code{Annotation_Level}: Annotation level ("major" or "subtype").
#'   \item \code{Status}: "Success" or "Failed".
#' }
#'
#' @examples
#' \dontrun{
#' # Example data
#' mock_data <- data.frame(
#'   cluster = rep(c("Cluster0", "Cluster1"), each = 15),
#'   gene = paste0("GENE", 1:30),
#'   avg_log2FC = runif(30, 1, 5)
#' )
#'
#' # Annotate major cell types
#' result_major <- AutoCellType(
#'   input = mock_data,
#'   tissuename = "human immune system",
#'   annotation_level = "major",
#'   topgenenumber = 5
#' )
#' print(result_major)
#'
#' # Annotate cell subtypes
#' result_subtype <- AutoCellType(
#'   input = mock_data,
#'   tissuename = "human immune system",
#'   annotation_level = "subtype",
#'   topgenenumber = 5
#' )
#' print(result_subtype)
#' }
#'
#' @references
#' OpenAI API Documentation: \url{https://platform.openai.com/docs/api-reference}
#'
#' @importFrom httr POST timeout
#' @importFrom dplyr filter group_by slice_max summarise
#' @importFrom tibble deframe
#' @importFrom purrr map safely
#' @importFrom glue glue
#' @importFrom stringr str_split str_extract
#' @export
AutoCellType <- function(
    input,
    tissuename = "default",
    annotation_level = "major",
    model = "gpt-4o",
    topgenenumber = 10,
    base_url = "https://api.openai.com/v1",
    api_key = NULL,
    timeout = 30,
    retries = 3
) {
  # Check for required packages
  required_packages <- c("openai", "dplyr", "httr", "purrr", "glue", "stringr")
  for (pkg in required_packages) {
    if (!requireNamespace(pkg, quietly = TRUE)) {
      stop(glue::glue("Please install the '{pkg}' package to use this function."))
    }
  }

  # Validate input
  if (missing(input)) stop("Input data is required.")
  if (!inherits(input, c("data.frame", "list"))) {
    stop("Input must be a data.frame (differential expression matrix) or a list of gene vectors.")
  }
  if (!is.numeric(topgenenumber) || topgenenumber <= 0) {
    stop("topgenenumber must be a positive integer.")
  }
  if (!annotation_level %in% c("major", "subtype")) {
    stop('annotation_level must be either "major" or "subtype".')
  }

  # Validate API key
  auth_key <- if (!is.null(api_key)) {
    api_key
  } else if (nzchar(Sys.getenv("OPENAI_API_KEY"))) {
    Sys.getenv("OPENAI_API_KEY")
  } else {
    stop("A valid API key is required (via api_key parameter or OPENAI_API_KEY environment variable).")
  }

  # Initialize OpenAI client
  client <- tryCatch({
    openai::OpenAI(api_key = auth_key, base_url = base_url)
  }, error = function(e) {
    stop("Failed to initialize OpenAI client: ", e$message)
  })

  # Process input data
  process_markers <- if (inherits(input, "data.frame")) {
    input %>%
      dplyr::filter(avg_log2FC > 0) %>%
      dplyr::group_by(cluster) %>%
      dplyr::slice_max(order_by = avg_log2FC, n = topgenenumber) %>%
      dplyr::summarise(genes = paste0(gene, collapse = ",")) %>%
      tibble::deframe()
  } else {
    sapply(input, paste0, collapse = ",")
  }

  cluster_list <- names(process_markers)
  batch_size <- 5
  batch_indices <- split(seq_along(cluster_list), ceiling(seq_along(cluster_list) / batch_size))

  # System prompt for GPT
  sys_prompt <- if (annotation_level == "major") {
    glue::glue(
      "您是基于单细胞转录组的细胞注释专家，任务是根据{tissuename}的标记基因识别主要细胞大类。注意细胞类型必须使用国际标准英文名称（如T cells而非T细胞）。

===== 专家级注释规范 =====
1. 分析流程图：
   组织特征分析 → 大类判定 → 质量控制 → 结果生成

2. 细胞大群分类体系（按CellMarker数据库标准）：
   IMMUNE CELLS:
   ├── Lymphoid: T cells (CD3D/E/G+), B cells (CD79A+, MS4A1+), NK cells (NCAM1+, KLRF1+)
   └── Myeloid: Monocytes (CD14+, S100A9+), Macrophages (CD68+, MARCO+), DC (CD1C+, CLEC9A+)

   STRUCTURAL CELLS:
   ├── Stromal: Fibroblasts (COL1A1+, DCN+), Endothelial (PECAM1+, VWF+)
   ├── Epithelial: Ductal cells (KRT19+), Acinar (PRSS1+)

   SPECIALIZED CELLS:
   ├── Neuronal: Glial cells (SOX10+), Neurons (SYT1+)
   └── Blood: RBC (HBA1+), Platelets (PPBP+)

3. 质量控制规则：
   ✔️ 必须满足以下任一条：
   a) ≥2个该类型特异基因（如T cell需同时有CD3E和CD3D）
   b) 高置信基因（如PanCK用于上皮）+ 支持基因（如与组织类型匹配的marker）

   ❌ 拒绝标注情形：
   ▸ 标记基因冲突（如同时含CD3D和CD79A）
   ▸ 泛用基因占比>50%（如高线粒体基因MT-）

4. 输出示例（注意保持细胞类型英文）：
   Cluster0: T cells (CD3D+, CD8A+)
   Cluster1: Fibroblasts (COL1A1hi)
   Cluster2: Undefined (low confidence)
   Cluster3: Myeloid cells (CD14+ TMEM119-)
"
    )
  } else {
    glue::glue(
      "您是单细胞亚群注释专家，任务是根据{tissuename}数据细化细胞亚型。所有细胞类型必须使用官方英文名称，亚型标记需符合文献规范。

===== 亚群注释算法 =====
1. 分析层级（必要时需两步确认）：
   大群->主群验证 → 亚型标记检查 → 活化状态评估 → 功能注释

2. 权威亚群标记标准

3. 严格质量控制

4. 输出规范示例：
   Format1: 明确亚群 → Cluster0: T cells - CD8+ cytotoxic (CXCR3hi TOX+)
   Format2: 部分特征 → Cluster1: B cells - memory-like (CD27+ CD38-)
   Format3: 证据不足 → Cluster2: Macrophages (subtype unclear)
   Format4: 疑似混合 → Cluster3: Mixed T/NK cells (CD8A+/NCAM1+)
"
    )
  }



  # Batch processing with error handling
  safe_request <- purrr::safely(function(cluster_ids, current_batch) {
    user_prompt <- glue::glue(
      "Annotate the following cell clusters:\n{glue::glue_collapse(cluster_ids, sep = '\n')}\n\nStrictly follow the response format: 'Cluster_name: Cell_type'."
    )

    response <- client$chat$completions$create(
      model = model,
      messages = list(
        list(role = "system", content = sys_prompt),
        list(role = "user", content = user_prompt)
      ),
      temperature = 0.1,
      max_tokens = 200
    )

    if (!is.null(response)) {
      parsed <- stringr::str_split(response$choices[[1]]$message$content, "\n")[[1]]
      valid_lines <- stringr::str_extract(parsed, "^\\s*Cluster\\w+:\\s+.+")
      valid_lines <- valid_lines[!is.na(valid_lines)]
      if (length(valid_lines) == length(cluster_ids)) {
        return(setNames(stringr::str_extract(valid_lines, "(?<=:)\\s*[^\\s]+"), cluster_ids))
      }
    }
    return(setNames(rep(NA_character_, length(cluster_ids)), cluster_ids))
  })

  final_result <- purrr::map(batch_indices, function(indices) {
    current_batch <- process_markers[indices]
    cluster_ids <- names(current_batch)
    result <- NULL
    attempt <- 0

    while (is.null(result) && attempt < retries) {
      result <- safe_request(cluster_ids, current_batch)$result
      attempt <- attempt + 1
    }

    result %||% setNames(rep(NA_character_, length(cluster_ids)), cluster_ids)
  })

  # Format final results
  result_df <- tibble::tibble(
    Cluster = unlist(lapply(final_result, names)),
    Prediction = unlist(final_result),
    Annotation_Level = annotation_level,
    Status = ifelse(is.na(unlist(final_result)), "Failed", "Success")
  )

  return(result_df)
}
