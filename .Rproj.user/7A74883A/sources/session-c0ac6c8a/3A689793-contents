#' Automated Cell Type Annotation with GPT Models
#'
#' This function leverages OpenAI GPT models to annotate cell clusters based on marker genes.
#'
#' @param input A differential expression matrix (data.frame) with columns 'cluster', 'gene' and 'avg_log2FC',
#' or a predefined list of gene vectors.
#' @param tissuename Character string specifying tissue type (e.g. "human pancreas") to improve accuracy.
#' @param annotation_level Level of annotation, either "major" (broad cell types) or "subtype" (detailed cell types).
#' Default is "major".
#' @param model OpenAI model name, default "gpt-4o". Fallback options include "gpt-4-turbo".
#' @param topgenenumber Number of top marker genes to use per cluster (default: 10).
#' @param base_url API endpoint (for advanced users).
#' @param api_key OpenAI API key. If `NULL`, uses the `OPENAI_API_KEY` environment variable.
#' @param timeout Network timeout in seconds (default: 30).
#' @param retries Maximum retry attempts on API failure (default: 3).
#'
#' @return A data.frame with 4 columns:
#' \itemize{
#'   \item \code{Cluster}: Cluster identifier.
#'   \item \code{Prediction}: Annotated cell type (`NA` if failed).
#'   \item \code{Annotation_Level}: Annotation level ("major" or "subtype").
#'   \item \code{Status}: "Success" or "Failed".
#' }
#'
#' @examples
#' \dontrun{
#' # Example data
#' mock_data <- data.frame(
#'   cluster = rep(c("Cluster0", "Cluster1"), each = 15),
#'   gene = paste0("GENE", 1:30),
#'   avg_log2FC = runif(30, 1, 5)
#' )
#'
#' # Annotate major cell types
#' result_major <- AutoCellType(
#'   input = mock_data,
#'   tissuename = "human immune system",
#'   annotation_level = "major",
#'   topgenenumber = 5
#' )
#' print(result_major)
#'
#' # Annotate cell subtypes
#' result_subtype <- AutoCellType(
#'   input = mock_data,
#'   tissuename = "human immune system",
#'   annotation_level = "subtype",
#'   topgenenumber = 5
#' )
#' print(result_subtype)
#' }
#'
#' @references
#' OpenAI API Documentation: \url{https://platform.openai.com/docs/api-reference}
#'
#' @importFrom httr POST timeout
#' @importFrom dplyr filter group_by slice_max summarise
#' @importFrom tibble deframe
#' @importFrom purrr map safely
#' @importFrom glue glue
#' @importFrom stringr str_split str_extract
#' @export
AutoCellType <- function(
    input,
    tissuename = "default",
    annotation_level = "major",
    model = "gpt-4o",
    topgenenumber = 10,
    base_url = "https://api.openai.com/v1",
    api_key = NULL,
    timeout = 30,
    retries = 3
) {
  # Check for required packages
  required_packages <- c("openai", "dplyr", "httr", "purrr", "glue", "stringr")
  for (pkg in required_packages) {
    if (!requireNamespace(pkg, quietly = TRUE)) {
      stop(glue::glue("Please install the '{pkg}' package to use this function."))
    }
  }

  # Validate input
  if (missing(input)) stop("Input data is required.")
  if (!inherits(input, c("data.frame", "list"))) {
    stop("Input must be a data.frame (differential expression matrix) or a list of gene vectors.")
  }
  if (!is.numeric(topgenenumber) || topgenenumber <= 0) {
    stop("topgenenumber must be a positive integer.")
  }
  if (!annotation_level %in% c("major", "subtype")) {
    stop('annotation_level must be either "major" or "subtype".')
  }

  # Validate API key
  auth_key <- if (!is.null(api_key)) {
    api_key
  } else if (nzchar(Sys.getenv("OPENAI_API_KEY"))) {
    Sys.getenv("OPENAI_API_KEY")
  } else {
    stop("A valid API key is required (via api_key parameter or OPENAI_API_KEY environment variable).")
  }

  # Initialize OpenAI client
  client <- tryCatch({
    openai::OpenAI(api_key = auth_key, base_url = base_url)
  }, error = function(e) {
    stop("Failed to initialize OpenAI client: ", e$message)
  })

  # Process input data
  process_markers <- if (inherits(input, "data.frame")) {
    input %>%
      dplyr::filter(avg_log2FC > 0) %>%
      dplyr::group_by(cluster) %>%
      dplyr::slice_max(order_by = avg_log2FC, n = topgenenumber) %>%
      dplyr::summarise(genes = paste0(gene, collapse = ",")) %>%
      tibble::deframe()
  } else {
    sapply(input, paste0, collapse = ",")
  }

  cluster_list <- names(process_markers)
  batch_size <- 5
  batch_indices <- split(seq_along(cluster_list), ceiling(seq_along(cluster_list) / batch_size))

  # System prompt for GPT
  sys_prompt <- if (annotation_level == "major") {
    glue::glue(
      "[[Expert System v3.2 - 细胞大群注释协议]]\n",
      "✧✧✧ 角色定义 ✧✧✧\n",
      "您是基于单细胞组学的智能注释系统，整合CellMarker 3.2（2024更新）、",
      "Human Cell Atlas和15万篇文献知识实现精准分类。需严格遵循国际细胞命名委员会（ICSN）最新指南。\n\n",

      "======= 核心分类框架 =======\n",
      "{wustl_start}Ⅰ. 三系层级分类树{wustl_end}\n",
      "# Immune Lineage\n",
      "→ T/NK：需满足CD3D/G或NCAM1+NKG7+\n",
      "→ B/Plasma：CD79A/MS4A1与SDC1/XBP1组合验证\n",
      "→ Myeloid：按SPP1/CXCL9表达谱分型\n",
      "   ├── SPP1+ Macro：VEGF通路富集（HIF1A>8）\n",
      "   └── CXCL9+ Macro：IFNγ响应特征（STAT1↑ IRF1↑）\n\n",

      "# Stromal Lineage\n",
      "→ Endothelial：CLDN5/VWF梯度分析（CLEC4G+肝特异）\n",
      "→ Fibroblasts：COL1A1与ACTA2表达模式验证\n",
      "   ├── Portal FB：MFAP5/GREM1+ (肝脏门静脉特化)\n",
      "   └── Mesangial：PDGFRB+NOTCH3+ (肾小球特化)\n\n",

      "# Epithelial Lineage\n",
      "→ 腺上皮：AMY2A/PRSS1+ (胰腺)\n",
      "→ 导管上皮：KRT19/CFTR+ (胆管系统)\n",
      "→ 屏障上皮：CLDN18/MUC5AC+ (肺/胃肠系统)\n\n",

      "======= 智能判别系统 =======\n",
      "{wustl_start}Ⓐ 量化决策矩阵{wustl_end}\n",
      "Defining Index = Σ(谱系主基因TPM) / Σ(总检测基因TPM)\n",
      "Contaminant Score = ∑(异源基因logFC²) / 前10主基因平均logFC\n\n",

      "{wustl_start}Ⓑ 动态分类阈值{wustl_end}",
      "1. Myeloid细胞：\n",
      "   SPP1 ≥12 | CXCL9 ≥15 | CD68 ≥20\n",
      "2. 组织特异内皮：\n",
      "   肝：CLEC4G ≥18 | 脑：CLDN5 ≥25\n",
      "3. 混合类型阈值：Dominance Rate <65%\n\n",

      "======= 质量控制体系 =======\n",
      "✔ 置信标注条件（需同时满足）:\n",
      "  1. 主基因覆盖度 ≥70% (按权重排序前5基因)\n",
      "  2. 异源基因污染指数 <0.3\n",
      "  3. Mito/Stress基因比例 <15%\n",
      "  4. 组织特异性评分 >TypeDB同类细胞的80%分位数\n\n",

      "✖ 排除标准（触发任一条即标记为低质量）:\n",
      "  1. Doublet特征：跨谱系基因共表达（如EPCAM+PECAM1+）\n",
      "  2. 应激状态：Heat shock基因TPM总和 > 主基因的60%\n",
      "  3. 物种混杂：检测到>5个小鼠特有基因（人类样本）\n\n",

      "======= 异常处理协议 =======\n",
      "[[Case 1]] 新型细胞类型\n",
      "→ Step1：执行跨数据库验证（Tabula Sapiens|Azimuth）\n",
      "→ Step2：检查最新预印本（bioRxiv/medRxiv最后30天）\n",
      "→ Step3：功能命名法（如'SPP1+ CXCL9+ Angio-Macro'）\n\n",

      "[[Case 2]] 过渡态细胞\n",
      "→ 适用状态：细胞周期（S期基因模块）| 转分化特征\n",
      "→ 注释格式：T cells [Transitioning] (G2M score>5)\n\n",

      "[[Case 3]] 基因型冲突\n",
      "→ 示例：NK细胞表达B细胞受体基因\n",
      "→ 处理：标记为'Undetermined (BCR+NKG7+)'\n\n",

      "======= 输出规范 =======\n",
      "[标准格式] ClusterX: 类型 (标志物模式)[置信度%] \n",
      "▶ 示例：\n",
      "Cluster8: SPP1+ Macrophages (SPP1hi LYZmid) [82%]\n",
      "Cluster12: Hepatocytes (ALBhigh APOElow) [95%]\n",
      "Cluster5: Cycling T cells (CD3D+ MKI67+) [63%]\n\n",

      "[特殊标记] \n",
      "◉ Provisional：需实验验证 → 添加*号\n",
      "◉ Contaminated：高污染 → 添加!号\n",
      "◉ Novel：文献未报道 → 引用PMID/预印本ID"
    )
  } else {
    glue::glue(
      "[[Expert System v3.2 - 细胞亚型注释协议]]\n",
      "✧✧✧ 亚型注释原则 ✧✧✧\n",
      "采用分层验证框架：\n",
      "主型验证 → 功能模块激活 → 亚型标志检测 → 跨平台一致性检验\n\n",

      "======= 细胞亚型数据库 =======\n",
      "{wustl_start}Ⓐ 巨噬细胞极化亚型{wustl_end}\n",
      "# M1 Spectrum\n",
      "◆ Classical M1：IFNγ主导 (CXCL9 ≥15, STAT1 ≥10)\n",
      "◆ Metabolic M1：脂代谢活跃 (SPP1 ≥18, LIPA ≥12)\n\n",

      "# M2 Spectrum\n",
      "◆ TREM2+ Macro：脂质处理 (TREM2 ≥20, APOE ≥15)\n",
      "◆ CXCL9+ Macro：免疫调节新型亚型 (SPP1+CXCL9+，参考bioRxiv:2023.123)\n\n",

      "{wustl_start}Ⓑ T细胞亚群标记{wustl_end}\n",
      "TRM：组织驻留标记 ≥2个 (CD69+, CXCR6+, ITGAE+)\n",
      "Tex：耗竭进展评分 >4.5 (TOX+ENTPD1+HAVCR2+)\n",
      "Tfh：生发中心关联 (BCL6 ≥8, IL21 ≥5)\n\n",

      "======= 多层次验证系统 =======\n",
      "{wustl_start}Ⓐ 标记基因层级{wustl_end}\n",
      "Level1: 必需基因（单敲除导致表型丢失）\n",
      "Level2: 辅助基因（增强亚型特异性）\n",
      "Level3: 排除基因（存在即否定该亚型）\n\n",

      "{wustl_start}Ⓑ 通路富集验证{wustl_end}\n",
      "▸ 使用REACTOME数据库检验通路一致性\n",
      "▸ 要求核心通路覆盖 ≥60% 标记基因\n",
      "示例：M2样Macro必须富集PPAR signaling\n\n",

      "======= 置信度评分标准 =======\n",
      "A. 高信度（≥85%）:\n   ✓ 匹配≥2独立研究\n   ✓ 关键标记log2FC ≥4\n\n",
      "B. 中信度（70-84%）:\n   ✓ 单队列支持+通路合理\n   ✓ 部分新标记需要验证\n\n",
      "C. 低信度（<70%）:\n   ✓ 跨平台一致性差\n   ✓ 存在拮抗标记（如CD8A+与CD4+共存）\n\n",

      "======= 动态命名机制 =======\n",
      "[[创新型亚型]]\n",
      "→ 格式：主型 [特征描述] (标志物组合)\n",
      "→ 示例：Macrophages [SPP1+Angio] (VEGFAhi FLT1+)\n\n",

      "[[争议性亚型]]\n",
      "→ 记录可能类型：T cells [CD4+/CD8αα争议]\n",
      "→ 需备注参考文献差异（PMID xxxx vs yyyy）\n\n",

      "======= 结果呈现规范 =======\n",
      "[标准格式] 亚型 (功能模块) [评分/参考文献]\n",
      "◆ 示例1：CD8+ TRM (Tissue-resident module) [88% | Nature 2023]\n",
      "◆ 示例2：SPP1+ Macro (VEGF-high) [91% | bioRxiv 2024.123]\n\n",

      "[警告标识]\n",
      "◉ 技术限制：低UMI细胞 → 添加▸标志\n",
      "◉ 批次效应：跨样本不一致 → 添加⚠标志"
    )
  }




  # Batch processing with error handling
  safe_request <- purrr::safely(function(cluster_ids, current_batch) {
    user_prompt <- glue::glue(
      "Annotate the following cell clusters:\n{glue::glue_collapse(cluster_ids, sep = '\n')}\n\nStrictly follow the response format: 'Cluster_name: Cell_type'."
    )

    response <- client$chat$completions$create(
      model = model,
      messages = list(
        list(role = "system", content = sys_prompt),
        list(role = "user", content = user_prompt)
      ),
      temperature = 0.1,
      max_tokens = 200
    )

    if (!is.null(response)) {
      parsed <- stringr::str_split(response$choices[[1]]$message$content, "\n")[[1]]
      valid_lines <- stringr::str_extract(parsed, "^\\s*Cluster\\w+:\\s+.+")
      valid_lines <- valid_lines[!is.na(valid_lines)]
      if (length(valid_lines) == length(cluster_ids)) {
        return(setNames(stringr::str_extract(valid_lines, "(?<=:)\\s*[^\\s]+"), cluster_ids))
      }
    }
    return(setNames(rep(NA_character_, length(cluster_ids)), cluster_ids))
  })

  final_result <- purrr::map(batch_indices, function(indices) {
    current_batch <- process_markers[indices]
    cluster_ids <- names(current_batch)
    result <- NULL
    attempt <- 0

    while (is.null(result) && attempt < retries) {
      result <- safe_request(cluster_ids, current_batch)$result
      attempt <- attempt + 1
    }

    result %||% setNames(rep(NA_character_, length(cluster_ids)), cluster_ids)
  })

  # Format final results
  result_df <- tibble::tibble(
    Cluster = unlist(lapply(final_result, names)),
    Prediction = unlist(final_result),
    Annotation_Level = annotation_level,
    Status = ifelse(is.na(unlist(final_result)), "Failed", "Success")
  )

  return(result_df)
}
